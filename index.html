<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>NodeJS Talk</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>NodeJS & and good programming practices</h1>
				</section>
				<section>
					<h1>About me</h1>
					<p>
						<img width="50%" src="img/marti.jpg" alt="" />
					</p>
					<aside class="notes">
					  I am a FE dev, but I'm not here to talk about FE, but mainly
						about BE.
						I come from a full stack background, mainly working with PHP for many years,
						CodeIgniter, Zend, Larabel a bit of Symphony, you name it.
						Since then I wanted to specialize on the FE since lately the paradigm
						has shifted heavily on doing more logic on the FE. But I found very difficult
						to get things done without a foot on the BE, NodeJS was the answer, it allowed
						me to prototype very quickly and more flexible than PHP.

						About two or three years ago, I started using Nodejs in production in high demand
						applications (thousands of requests per second).
					</aside>
				</section>
				<section>
					<h1>About this talk</h1>
					<h2>Part1: NodeJS + Q&A</h2>
					<h2>Part2: Programming practices + Q&A</h2>
					<aside class="notes">
					  This talk will have two parts, almost with separate subjects,
						the first part will be about Nodejs, its strengths and clear some
						misconceptions around it.

						The second part will be around a couple programming techniques I've adopted
						which I find has helped me keep a more readable and clean codebase and avoid
						bugs from the start.
					</aside>
				</section>

				<section>
					<h1>Part 1: NodeJS</h1>

					<ul>
						<li>Brief introduction to NodeJS</li>
						<li>How does it work</li>
						<li>Companies using Node and why</li>
						<li>Strengths</li>
						<li>Misconceptions</li>
					</ul>

				</section>

				<section>
					<h2>What is Node.js?</h2>
					<p>
						<blockquote cite="https://nodejs.org/en/">
							Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.
						</blockquote>
						<small>Note: V8 compiles Javascript into machine code on the fly!</small>

						<aside class="notes">
						  This is the format definition of Node. There are some concepts here
							that are quite vague and not clear at first glance, so I want to give
							you a quick peek to the guts of the language, so you can see
							where it all comes from.
						</aside>
					</p>
				</section>

				<section>
					<h2>Node is FAST</h2>
					<p>
						Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.<br />
						<img src="img/n_queens_graph.jpg" alt="Node vs Python" />
						<img src="img/nodejs-vs-php-perf.png" alt="Node vs PHP" />
					</p>
					<aside class="notes">
					  I'm not usually a fan of benchmarks or comparisons, but when you're talking
						about speed you need to do it in context of others. These charts have different
						metrics by the way.
					</aside>
				</section>

				<section>
					<h2>Asynchronous and Event Driven</h2>
					<p>
						All APIs of Node.js library are asynchronous that is, non-blocking. <strong>There is no sleep on Node</strong>.<br />
						<img width="50%" src="img/event-loop.png" title="Node processing model" />
					</p>
					<aside class="notes">
						I'm sure most of you have seen this diagram before,
					  but to really understand why Node is so fast and can take so many
						requests with a single thread and understand this event loop model
						a bit more in depth we need to look at the internals.
					</aside>
				</section>

				<section>
					<h2>The internals</h2>
					<p>
						The trick? The most important and critical parts are written in C/C++
						<img src="img/node-parts.png" />
					</p>
					<aside class="notes">
					  All of us now, you can't get any faster than C/C++, V8 is written in C++,
						libuv it's a C library that provides all the async features, maintains the
						event loops, a thread pool, file system, I/O, network, and other critical applications.

						Yes, I said thread pool, although Javascript runs in a single thread, the
						on the other side of the event loop libuv maintains a pool of thread workers
						to be able to do concurrent synchronous operations. This allows us to get
						the best of threads without having to worry about them in our code.

						The Bindings are the glue that binds Javascript and the C modules and lets them
						talk with each other.

						Third party libraries can have C bindings too, which are compiled for your
						machine when you install them, i.e. node-sass
					</aside>
				</section>

				<section>
					<h2>Single Threaded but Highly Scalable</h2>
					<p>
						Node.js uses a single threaded model with event looping.<br/>
						<img src="img/single-thread.png" title="Single thread example" />
					</p>
					<aside class="notes">
					  Traditionally, when a request comes in, the application would handle the
						request and halt all other operations until the request is processed.
						This immediately presents a problem: when a large number of requests
						come in at the same time, each request would have to wait until the
						previous requests are processed. In other words, the previous
						operation will block the ones following it. To make it worse,
						if the previous requests have long response time,
						all other requests would be halted/blocked for a long time.

						To address this issue, one can resort to multiprocessing and/or multithreading
						as solutions, each with its own pros and cons. Node.js handles things differently.
						Instead of spawning a new thread for every new request, all the requests are handled
						on one single main thread, and that’s pretty much all that it does: handle requests.

						All (I/O) operations contained in the request,
						such as file system access, database read/write,
						are sent to the worker threads maintained by libuv (mentioned above)
						in the background. In other words, I/O operations in the requests
						are handled asynchronously, not on the main thread.
					</aside>
				</section>

				<section>
					<h2>How does all work then?</h2>
					<p>
						The restaurant analogy:<br />
						<img width="50%" src="img/waiter-order.jpg" />
					</p>

					<aside class="notes">
					  The waiter is our Main Thread, the Node process.
						The waiter takes the order from a request, that order is an event
					</aside>
				</section>

				<section>
					<h2>How does all work then?</h2>
					<p>
						<img src="img/waiter-kitchen.jpg" alt="" />
					</p>

					<aside class="notes">
						The waiter leaves the order with the cooks.
						The cooks are the the libuv worker threads, they are really fast
						and efficient, when they're finished they give the output (the dish)
						back to the waiter who brings it back to the user.

						Notice how the hard work is done at the kitchen, but the waiter is
						never blocked, he just runs around carrying orders.

						The waiter going back and forth is the event loop
					</aside>
				</section>

				<section>
					<h3>Some companies using Node.js in production</h3>
					<ol>
						<li><a target="_blank" href="https://www.youtube.com/watch?v=gtjzjiTI96c&list=PLfXiENmg6yyUpIVY9XVOkbdmBPx6PUm9_">Netflix</a></li>
						<li><a target="_blank" href="https://source.opennews.org/en-US/articles/nyt-redesigns-mobile/">New York Times</a></li>
						<li><a target="_blank" href="https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/">PayPal</a> </li>
						<li><a target="_blank" href="http://highscalability.com/blog/2012/10/4/linkedin-moved-from-rails-to-node-27-servers-cut-and-up-to-2.html">LinkedIn</a></li>
						<li><a target="_blank" href="https://medium.com/@nodejs/how-uber-uses-node-js-to-scale-their-business-cd4d8f8e4187#.rf4v5rw0w">Uber</a> </li>
						<li><a target="_blank" href="https://www.joyent.com/blog/node-js-at-walmart-introduction">Wallmart</a> </li>
						<li><a target="_blank" href="http://blog.fogcreek.com/the-trello-tech-stack/">Trello</a></li>
						<li><a target="_blank" href="http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/">Airbnb</a></li>
					</ol>

					<aside class="notes">
					  These companies receive an insane amount of requests,
						the scale on which they work is gigantic, and they've chosen
						node because of their scalability and easy of use.

						In fact lets read it from the guys themselves.
					</aside>
				</section>

				<section>
					<h2>Paypal</h2>
					<p>
						<img width="90%" src="img/paypal.png"  />

						<aside class="notes">
						  PayPal has rewritten part of their existing applications using Node, so they
							where able to measure the difference, the gain, in empirical numbers of
							using Node.
						</aside>
					</p>
				</section>

				<section>
					<h2>LinkedIn</h2>
					<p>
						<img width="90%" src="img/linked-in.png" />

						<aside class="notes">
						  LinkedIn did the same and have seen an increase in speed while
							decreasing the amount of computing power required.
						</aside>
					</p>
				</section>

				<section>
					<h2>Uber</h2>
					<p>
						<img width="90%" src="img/uber.png" />

						<aside class="notes">
						  You're starting to see a pattern here right? Node is really good
							at scaling at pace.
						</aside>
					</p>
				</section>

				<section>
					<h2>Wallmart</h2>
					<p>
						<img src="img/wallmart.png" alt="" />
					</p>

					<aside class="notes">
					  This is a frame from a talk from Walmart (the link is on the slides),
						where they talked about how they use Node, this image feels quite familiar
						with what we have at GOL as a backend.

						They actually created and open sourced a pretty good plugin based server
						library called hapi, according to their website used by companies like
						Disney, Macy's, mozilla, PayPal and others.
					</aside>
				</section>

				<section>
					<h2>Scale</h2>
					<p>
						Is it all the InfraDevs job? Or can we do something about it?<br />
						<img src="img/devops.jpg" alt="" />
					</p>

					<aside class="notes">
					  I think we sould all realise that scale is a systemic issue,
						you don't solve it in just one end of the chain, it needs to
						be build inside the project.

						Build to scale from the start and you'll never have to worry about load.
					</aside>
				</section>

				<section>
					<h2>Scale</h2>
					<p>
						In two commands you can have a cluster, one instance per CPU
<pre><code class="hljs sh" data-trim contenteditable>
$ npm install pm2 --global
$ pm2 start app.js -i 0
</code></pre>
						<img src="img/pm2.png" />
					</p>

					<aside class="notes">
					  PM2 is a wonderful tool, it's the best process manager for node out there,
						Makes sure your application is always running, even after a crash,
						allows you to demonize your app,
						gathers logs for you,
						and lets you run in cluster mode.

						By running this command I now have quadrupled the amount of requests
						my application can handle, and that's only on my laptop, can you imagine
						what you can do on a 32 CPU AWS machine? Maybe you don't need that many servers
						after all.
					</aside>
				</section>

				<section>
					<h2>Abundance</h2>
					<p>
						Javascript was the most popular language in 2015 by third year in a row.<br />
						<img src="img/overflow.png" /><br />
						<small>StackOverflow</small>
					</p>

					<aside class="notes">
					  I'm not saying it's not difficult to find a good Node developer,
						but the pool of possible applicants is way way bigger than say Go developers.

						The language is not new, it has been around for a long time, but has been able
						to modernize and grow, new patterns are emerging.
					</aside>
				</section>

				<section>
					<h2>Versatility</h2>
					<p>
						What would you say if you could have an engineer that could do all these things:
						<ul>
							<li><a target="_blank" href="http://www.nodecopter.com/">Drones</a></li>
							<li><a target="_blank" href="http://node-ardx.org/">Arduino</a></li>
							<li><a target="_blank" href="http://electron.atom.io/">Cross-platform Desktop apps</a></li>
							<li><a target="_blank" href="https://facebook.github.io/react-native/">Native mobile apps</a></li>
							<li><a target="_blank" href="https://developer.atlassian.com/blog/2015/11/scripting-with-node/">Command line tools</a></li>
							<li><a target="_blank" href="https://github.com/pebble/pebblejs">Smart watches</a></li>
						</ul>
					</p>

					<aside class="notes">
					  What would you think if I tell you, you can have an engineer that can code:...
					</aside>
				</section>

				<section>
					<h2>Versatility</h2>
					<p>
						Oh.. and you know, universal (isomorphic) web applications.<br />
						<img src="img/mind_blown.gif" alt="" />
					</p>
					<aside class="notes">
					  The case of universal or isomorphic applications could take a whole talk
						by itself, but it is a trend that is gaining traction on the web industry,
						and one that can obviously can only be solved by Node.

						The practicality of reusing the same code you use on the frontend as a single page
						app to render on the server side is undeniable, and solves most of the problems
						associated with the rising of frontend frameworks and libraries.

						This is the approach we're following at Texan and is giving very good results.
					</aside>
				</section>

				<section>
					<h2>Fast to learn, fast to code, fast to execute</h2>
					<p>
						It's perfect for an agile environment, you can quickly build an MVP and
						keep iterating until you have all the features you need.
					</p>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>Tooling is too cumbersome</h3>
					<p>
						Node !== Frontend<br />
						You don't need the same tooling on the backend than you need on the frontend.<br />
						<a target="_blank" href="https://nodejs.org/en/blog/release/v6.0.0/">Node v6 (soon to become LTS)</a> supports most of ES6 (96% at the time of this presentation), no need for transpiling.<br />
						No need for gulp/grunt, npm scripts can solve all your needs (start, test, build, etc).
					</p>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>NPM installs a bunch of nested dependencies</h3>
					<p>
						As of NPM v3 dependencies are installed in a flatten file structure, if the same package
						is needed in a bunch of dependencies it's only installed once.
					</p>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>You need a lot of micro-dependencies</h3>
					<p>
						No need for frameworks and all their baggage.<br />
						To write a proper microservice you really only need 3 packages, the implementation is up to you.
						<ul>
							<li>A server (such as <code>restify</code>)</li>
							<li>A db handler/model (such as <code>mongoose</code>)</li>
							<li>A logger (such as <code>bunyan</code>)</li>
							<li>Or a fetch library if your data lives somewhere else (such as <code>node-fetch</code>)</li>
						</ul>
					</p>

					<aside class="notes">
						Other people might complain about third party packages not being updated or
					  All languages have dependencies in other people's packages, I think it
						would be an error to think this is a Node problem
					</aside>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>Callback hell / Pyramid of doom</h3>
<pre><code class="hljs js" data-trim contenteditable>
asyncStuff1( ( err, result1 ) => {
	if ( err ) //handle error
  asyncStuff2( result1, ( err, result2 ) => {
		if ( err ) //handle error
    asyncStuff3( result2, ( err, result3 ) => {
			if ( err ) //handle error
      asyncStuff4( result3, ( err, result4 ) => {
				if ( err ) //handle error
        asyncStuff5( result4, ( err, result5 ) => {
					if ( err ) //handle error
          // do something useful
        })
      })
    })
  })
})
</code></pre>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>This is solved by Promises</h3>
<pre><code class="hljs js" data-trim contenteditable>
asyncStuff1()
.then( asyncStuff2 )
.then( asyncStuff3 )
.then( asyncStuff4 )
.then( asyncStuff5 )
.catch( error => {
	//Write only one error handler
	//All errors will come here
})
</code></pre>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>Is not reliable</h3>
					<p>
						Node has grown a lot and fast lately, there was troubled times at the beginning, but
						it now has a strong open source foundation behind it, and a robust community making it
						more secure, fast and reliable every day.
					</p>
				</section>

				<section>
					<h2>My favorites</h2>
					<ul>
						<li>Isomorphic SSR</li>
						<li>Websockets</li>
						<li>JSON</li>
						<li>
							ES6
							<ul>
								<li>Arrow functions <code>x => x * 2</code></li>
								<li>Promises</li>
								<li>Short notations in general <code>{ prop }</code></li>
								<li>Deconstruction <code>{ prop1, prop2 } = obj</code></li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>End of part 1</h2>
					<h3>Q&A</h3>
					<blockquote cite="https://blog.codinghorror.com/the-principle-of-least-power/">
						"Any application that can be written in JavaScript, will eventually be written in JavaScript"<br /><br />
						<small>-- "Atwood's Law" (Jeff Atwood, 2007)</small>
					</blockquote>

					<aside class="notes">
					  I want to end part 1 with this quote from Jeff Atwood, Jeff is a co-founder at StackOverflow
						and creator of Discourse forum solution.

						It comes from 'The Principle of Least Power' formulated Tim Berners-Lee:
						Principle: Powerful languages inhibit information reuse.
						Good Practice: Use the least powerful language suitable for expressing information, constraints or programs on the World Wide Web.
					</aside>
				</section>

				<section>
					<h2>Part 2: Programming techniques</h2>
					<p>
						Goals<br />
						Make our code:

						<ul>
							<li>Easy to read</li>
							<li>Easy to understand</li>
							<li>Easy to reason about</li>
						</ul>
					</p>

					<aside class="notes">
					  Reason about refers to executing the code in our heads,
						we read thousands of lines of code every day, the quicker we can
						comprehend what it does and follow the execution the better we
						can find bugs and refactor different bits.

						As a rule of thumb, you could measure as how fast can you give me
						an output given a certain input.
					</aside>
				</section>

				<section>
					<h2>Return early technique</h2>
					<img width="70%" src="img/return-early.jpg" alt="" />

					<aside class="notes">
					  This a language agnostic technique, you can apply it almost
						any back end and front end language.

						Most of you are probably using this already, but we have developers
						with all kinds of experiences here and I think it's a good pattern
						for everyone to know.
					</aside>
				</section>

				<section>
					<h2>Initial code</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
	let { errorKey, errorMessage } = error;

	let errorString = '';

	if ( errorKey ) {
		if ( errorConstants[ errorKey ] ) {
			errorString = errorConstants[ errorKey ];
		} else if ( errorMessage ) {
			errorString = errorMessage;
		} else {
			errorString = errorKey;
		}
	} else if ( typeof error === 'string' ) {
		if ( errorConstants[ error ] ) {
			errorString = errorConstants[ error ];
		} else {
			errorString = error;
		}
	} else {
		errorString = config.MAIN_ERROR;
	}

	return errorString;
};
					</code></pre>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img src="img/conditional-tree.png" alt="" />
					</p>

					<aside class="notes">
					  In here we can see the tree that we need to create in our
						head in order to branch through the different scenarios.

						When I mentioned the reason about part, this is what happens in
						your head when you try to get an output.

						The highlighted leaf nodes represent the values that we return,
						this is really the functionality we expect from our function the output
						we need, but there are other ways of getting that output.
					</aside>
				</section>

				<section>
					<h2>Cut down the <code>else</code>s</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey ) {
    if ( errorConstants[ errorKey ] ) return errorConstants[ errorKey ];
    if ( errorMessage  ) return errorMessage;
    return errorKey;
  }

  if ( typeof error === 'string' ) {
    if ( errorConstants[ error ] ) return errorConstants[ error ];
    return error;
  }

  return config.MAIN_ERROR;
};
					</code></pre>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img src="img/conditional-tree-mod1.png" alt="" />
					</p>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img src="img/conditional-tree-mod1-s.png" alt="" />
					</p>

					<aside class="notes">
					  This is much much better now, we reduced the number of branches
						on our tree, and its now more straight forward.

						But there's still another improvement we can do, and this might
						be counter intuitive at first for some of you, but bear with me.
					</aside>
				</section>

				<section>
					<h2>One <code>if</code> deep</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey && errorConstants[ errorKey ] ) return errorConstants[ errorKey ];
  if ( errorKey && errorMessage  ) return errorMessage;
  if ( errorKey ) return errorKey;

  if ( typeof error === 'string' && errorConstants[ error ] ) return errorConstants[ error ];
  if ( typeof error === 'string' ) return error;

  return config.MAIN_ERROR;
};
					</code></pre>
				</section>

				<section>
					<h2>One <code>if</code> deep</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey
    && errorConstants[ errorKey ] ) return errorConstants[ errorKey ];

  if ( errorKey
    && errorMessage  ) return errorMessage;

  if ( errorKey ) return errorKey;

  if ( typeof error === 'string'
    && errorConstants[ error ] ) return errorConstants[ error ];

  if ( typeof error === 'string' ) return error;

  return config.MAIN_ERROR;
};
					</code></pre>

					<aside class="notes">
					  Now our function is just a series of if statements, we know
						that each of them is only going to happen if none of the previous ones
						happened, and of top of it, it's so declarative it's almost as reading plain
						english.
					</aside>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img width="75%" src="img/conditional-tree-mod2.png" alt="" />
					</p>

					<aside class="notes">
					  Wow, isn't this tree gorgeous? We managed to cut down the branches
						to almost the same depth.

						Now when we read this code given an input we can almost tell instantly
						what the output is because the conditions are written in plain english.
					</aside>
				</section>

				<section>
					<h2>Before and after</h2>
					<pre class="half"><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
	let { errorKey, errorMessage } = error;

	let errorString = '';

	if ( errorKey ) {
		if ( errorConstants[ errorKey ] ) {
			errorString = errorConstants[ errorKey ];
		} else if ( errorMessage ) {
			errorString = errorMessage;
		} else {
			errorString = errorKey;
		}
	} else if ( typeof error === 'string' ) {
		if ( errorConstants[ error ] ) {
			errorString = errorConstants[ error ];
		} else {
			errorString = error;
		}
	} else {
		errorString = config.MAIN_ERROR;
	}

	return errorString;
};
					</code></pre>
					<pre class="half"><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey && errorConstants[ errorKey ] ) return errorConstants[ errorKey ];
  if ( errorKey && errorMessage  ) return errorMessage;
  if ( errorKey ) return errorKey;

  if ( typeof error === 'string' && errorConstants[ error ] ) return errorConstants[ error ];
  if ( typeof error === 'string' ) return error;

  return config.MAIN_ERROR;
};
					</code></pre>
				</section>

				<section>
					<h2>Recap</h2>
					<p>
						When you see lots of nested <code>if</code> or/and lots of <code>else</code> statements:

						<ol>
							<li>Cut down the <code>else</code>s</li>
							<li>One <code>if</code> deep</li>
						</ol>
					</p>

					<aside class="notes">
					  We've done all of this with only two simple steps.
					</aside>
				</section>

				<section>
					<h2>Functional programming</h2>

				</section>

				<section>
					<h2>Principles</h2>
					<p>
						A set of patterns when we write our code:
						<ul>
							<li>Small modular functions</li>
							<li>Pure functions
								<ul>
									<li>No side effects</li>
									<li>Data should be immutable</li>
									<li>Avoid non predictable functions (Date)</li>
								</ul>
							</li>
							<li>Stateless</li>
							<li>Composable</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>ROI</h2>
					<p>
						<ul>
							<li>Testable</li>
							<li>Portable (reusable)</li>
							<li>Memoizable</li>
							<li>Parallelizable</li>
							<li>Less prone to bugs</li>
							<li>More readable</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Our array helpers</h2>
					<h3>Map</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Multiply all the elements by 2 */
a.map( x => x * 2 );
//[ 2, 4, 6, 8 ]
</code></pre>
					<aside class="notes">
					  Notice that a is constant, therefore map is returning
						a new array with the same length as the original one.
					</aside>
				</section>

				<section>
					<h2>Our array helpers</h2>
					<h3>forEach</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Log every array element */
a.forEach( x => console.log(x) );
//1
//2
//3
//4
</code></pre>

					<aside class="notes">
					  forEach lets us traverse an array applying
						a callback to each element
					</aside>
				</section>

				<section>
					<h2>Our array helpers</h2>
					<h3>filter</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Return an array with pair numbers */
a.filter( x => x % 2 === 0 );
//[ 2, 4 ]
</code></pre>
				</section>

				<section>
					<h2>Our array helpers</h2>
					<h3>reduce</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Sum all elements of the array */
a.reduce( ( previous, current ) => previous + current, 0 );
//10
const b = [ 'John Smith', 'George Clooney' ];
/* Produce an object an array with all firstNames and all lastNames */
b.reduce( ( previous, current ) => {
	let parts = current.split(' ');
	previous.firstNames.push( parts[0] );
	previous.lastNames.push( parts[1] );
	return previous;
}, {
	firstNames: [],
	lastNames: []
});
//{ firstNames: [ 'John', 'George' ],
//  lastNames: [ 'Smith', 'Clooney' ] }
</code></pre>

					<aside class="notes">
					  Reduce is maybe the most powerful of all and the most
						underused
					</aside>
				</section>

				<section>
					<h2>Our array helpers</h2>
					<h3>All together now</h3>
<pre><code class="hljs js height-auto" data-trim contenteditable>
const c  = [
	{ name: 'John', vote: 'leave', age: 60 },
	{ name: 'Mary', vote: 'remain', age: 25 },
	{ name: 'Dorothy', vote: 'leave', age: 75 },
	{ name: 'Mark', vote: 'remain', age: 35 },
];
/* Calculate average age of remain and leave voters */

let leaveVoters = c.filter( x => x.vote === 'leave' );
let leaveAgeSum = leaveVoters.reduce( ( p, c ) => p + c.age, 0 );
let leaveAvg    = leaveAgeSum / leaveVoters.length
//67.5

let remainVoters = c.filter( x => x.vote === 'remain' );
let remainAgeSum = remainVoters.reduce( ( p, c ) => p + c.age, 0 );
let remainAvg 	 = remainAgeSum / remainVoters.length;
//30
</code></pre>
				</section>

				<section>
					<h2>Create pure functions</h2>
<pre><code class="hljs js" data-trim contenteditable>
const filterVoters = ( c, type ) => c.filter( x => x.vote === type );

const sumAge       = c => c.reduce( ( p, c ) => p + c.age, 0 );

const calcAvg      = ( sum, total ) => sum / total;
</code></pre>
				</section>

				<section>
					<h2>Make them chainable</h2>
<pre><code class="hljs js" data-trim contenteditable>
const filterVoters = ( c, type ) => c.filter( x => x.vote === type );

const sumAge       = c => ({
	sum  : c.reduce( ( p, c ) => p + c.age, 0 ),
	total: c.length
});

const calcAvg      = ( params ) => params.sum / params.total;

calcAvg( sumAge( filterVoters( c, 'leave' ) ) );
//67.5

calcAvg( sumAge( filterVoters( c, 'remain' ) ) );
//30
</code></pre>
				</section>

				<section>
					<h2>Intermission: Promises</h2>
					<h4>They're useful for async stuff</h4>
					<p>
<pre><code class="hljs js" data-trim contenteditable>
const doSomethingAsync = ( a ) => {
	return new Promise(( resolve, reject) => {
		asyncThing(( err, result) => {
			if ( err ) return reject( err );
			return resolve( result );
		})
	})
};

doSomethingAsync( a )
.then( x => console.log(x) )
.catch( err => console.error(err) )
</code></pre>
					</p>
				</section>

				<section>
					<h2>Intermission: Promises</h2>
					<h4>But they're also useful for non async stuff</h4>
<pre><code class="hljs js" data-trim contenteditable>
const multiplyByTwo = ( a ) => {
	if ( isNaN(a) ) return Promise.reject( 'Not a number' );
	return Promise.resolve( a * 2 );
};

multiplyByTwo( a )
.then( x => console.log(x) )
.catch( err => console.error(err) )
</code></pre>
				</section>

				<section>
					<h2>Use Promise.resolve</h2>
<pre><code class="hljs js height-auto" data-trim contenteditable>
const filterVoters = ( c, type ) => Promise.resolve(
	c.filter( x => x.vote === type )
);

const sumAge       = c => Promise.resolve({
	sum  : c.reduce( ( p, c ) => p + c.age, 0 ),
	total: c.length
});

const calcAvg      = ( params ) => Promise.resolve(
	params.sum / params.total
);

filterVoters( c, 'leave' )
.then(sumAge)
.then(calcAvg)
.then( x => console.log(x) );
//67.5

filterVoters( c, 'remain' )
.then(sumAge)
.then(calcAvg)
.then( x => console.log(x) );
//30
</code></pre>
				</section>

				<section>
					<h2>Error handling</h2>
<pre><code class="hljs js height-auto" data-trim contenteditable>
const filterVoters = ( c, type ) => {
	if ( !c.length ) return Promise.reject('Empty array');
	return Promise.resolve( c.filter( x => x.vote === type ) )
};

const sumAge       = c => Promise.resolve({
	sum  : c.reduce( ( p, c ) => p + c.age, 0 ),
	total: c.length
});

const calcAvg      = ( params ) => Promise.resolve(
	params.sum / params.total
);

filterVoters( [], 'leave' )
.then(sumAge)
.then(calcAvg)
.then( x => console.log(x) )
.catch( error => console.log('Error!', error) );
//Error! Empty array
</code></pre>
				</section>

				<section>
					<h2>Recap</h2>
					<p>
						<ul>
							<li>Use array helpers</li>
							<li>Create small pure functions</li>
							<li>Make them reusable</li>
							<li>Make them chainable</li>
							<li>Test them</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>End of part 2</h2>
					<h3>Q&A</h3>
					<p>
						<blockquote cite="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4#.a41dwcshm">
							"Developers proficient in functional programming are going to be
							in large demand in the very near future."<br /><br />
							<small>-- Eric Elliott, 2014 </small>
						</blockquote>
					</p>
				</section>

				<section>
					<h2>Thank you!</h2>
					<p>
						<ul>
							<li>This slides: <a target="_blank" href="http://bit.ly/node-talk">http://bit.ly/node-talk</a></li>
							<li>Nodejs Workshop: <a target="_blank" href="http://bit.ly/node-workshop">http://bit.ly/node-workshop</a></li>
							<li>Discuss: <a target="_blank" href="https://sainsburyslab.slack.com/messages/discuss-nodejs/">#discuss-nodejs</a></li>
							<li>Slack me: <a target="_blank" href="https://sainsburyslab.slack.com/messages/@marti/">@marti</a></li>
						</ul>
					</p>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				transition: 'convex',
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({tabReplace: '  '}); hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
