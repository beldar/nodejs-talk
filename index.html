<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>NodeJS Talk</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>NodeJS & and good programming practices</h1>
				</section>
				<section>
					<h1>About me</h1>
					<h4>Marti Planellas</h4>
					<p>
						<img width="45%" src="img/marti.jpg" alt="" />
					</p>
					<aside class="notes">
					  I am a FE dev, but I'm not here to talk about FE, but mainly
						about BE.
						I come from a full stack background, mainly working with PHP for many years,
						CodeIgniter, Zend, Larabel a bit of Symphony, you name it.
						Since then I wanted to specialize on the FE since lately the paradigm
						has shifted heavily on doing more logic on the FE. But I found very difficult
						to get things done without a foot on the BE, NodeJS was the answer, it allowed
						me to prototype very quickly and more flexibly than PHP.

						About two or three years ago, I started using Nodejs in production in high demand
						high scale applications (thousands of requests per second).
					</aside>
				</section>
				<section>
					<h1>About this talk</h1>
					<h2>Part1: NodeJS + Q&A</h2>
					<h2>Part2: Programming practices + Q&A</h2>
					<aside class="notes">
					  This talk will have two parts, almost with separate subjects,
						the first part will be about Nodejs, its strengths and clear some
						misconceptions around it.

						The second part will be around a couple programming techniques I've adopted
						which I find has helped me keep a more readable and clean codebase and avoid
						bugs from the start.
					</aside>
				</section>

				<section>
					<h1>Part 1: NodeJS</h1>

					<ul>
						<li>Brief introduction to NodeJS</li>
						<li>How does it work</li>
						<li>Companies using Node and why</li>
						<li>Strengths</li>
						<li>Misconceptions</li>
					</ul>

				</section>

				<section>
					<h2>What is Node.js?</h2>
					<p>
						<blockquote cite="https://nodejs.org/en/">
							Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.
						</blockquote>
						<small>Note: V8 compiles Javascript into machine code on the fly!</small>

						<aside class="notes">
						  This is the formal definition of Node. There are some concepts here
							that are quite vague and not clear at first glance, so I want to give
							you a quick peek to the guts of the language, so you can see
							where it all comes from.
						</aside>
					</p>
				</section>

				<section>
					<h2>Node is FAST</h2>
					<p>
						Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.<br />
						<img src="img/n_queens_graph.jpg" alt="Node vs Python" />
						<img src="img/nodejs-vs-php-perf.png" alt="Node vs PHP" />
					</p>
					<aside class="notes">
					  I'm not usually a fan of benchmarks or comparisons, but when you're talking
						about speed you need to do it in context of others. These charts have different
						metrics by the way.
					</aside>
				</section>

				<section>
					<h2>Asynchronous and Event Driven</h2>
					<p>
						All APIs of Node.js library are asynchronous that is, non-blocking. <strong>There is no sleep on Node</strong>.<br />
						<img width="70%" src="img/event-loop.png" title="Node processing model" />
					</p>
					<aside class="notes">
						I'm sure most of you have seen this diagram before,
					  but to really understand why Node is so fast and can take so many
						requests with a single thread and understand this event loop model
						a bit more in depth we need to look at the internals.
					</aside>
				</section>

				<section>
					<h2>The internals</h2>
					<p>
						The trick? The most important and critical parts are written in C/C++
						<img src="img/node-parts.png" />
					</p>
					<aside class="notes">
					  All of us now, you can't get any faster than C/C++, V8 is written in C++,
						libuv it's a C library that provides all the async features, maintains the
						event loops, a thread pool, file system, I/O, network, and other critical applications.

						Yes, I said thread pool, although Javascript runs in a single thread, the
						on the other side of the event loop libuv maintains a pool of thread workers
						to be able to do concurrent synchronous operations. This allows us to get
						the best of threads without having to worry about them in our code.

						The Bindings are the glue that binds Javascript and the C modules and lets them
						talk with each other.

						Third party libraries can have C bindings too, which are compiled for your
						machine when you install them, i.e. node-sass
					</aside>
				</section>

				<section>
					<h2>Single Threaded but Highly Scalable</h2>
					<p>
						Node.js uses a single threaded model with event looping.<br/>
						<img src="img/single-thread.png" title="Single thread example" />
					</p>
					<aside class="notes">
					  Traditionally, when a request comes in, the application would handle the
						request and halt all other operations until the request is processed.
						This immediately presents a problem: when a large number of requests
						come in at the same time, each request would have to wait until the
						previous requests are processed. In other words, the previous
						operation will block the ones following it. To make it worse,
						if the previous requests have long response time,
						all other requests would be halted/blocked for a long time.

						To address this issue, one can resort to multiprocessing and/or multithreading
						as solutions, each with its own pros and cons. Node.js handles things differently.
						Instead of spawning a new thread for every new request, all the requests are handled
						on one single main thread, and that’s pretty much all that it does: handle requests.

						All (I/O) operations contained in the request,
						such as file system access, database read/write,
						are sent to the worker threads maintained by libuv (mentioned above)
						in the background. In other words, I/O operations in the requests
						are handled asynchronously, not on the main thread.
					</aside>
				</section>

				<section>
					<h2>How does all work then?</h2>
					<p>
						The restaurant analogy:<br />
						<img width="50%" src="img/waiter-order.jpg" />
					</p>

					<aside class="notes">
					  The waiter is our Main Thread, the Node process.
						The waiter takes the order from a request, that order is an event
					</aside>
				</section>

				<section>
					<h2>How does all work then?</h2>
					<p>
						<img src="img/waiter-kitchen.jpg" alt="" />
					</p>

					<aside class="notes">
						The waiter leaves the order with the cooks.
						The cooks are the the libuv worker threads, they are really fast
						and efficient, when they're finished they give the output (the dish)
						back to the waiter who brings it back to the user.

						Notice how the hard work is done at the kitchen, but the waiter is
						never blocked, he just runs around carrying orders.

						The waiter going back and forth is the event loop, that's it.
					</aside>
				</section>

				<section>
					<h3>Some companies using Node.js in production</h3>
					<ol>
						<li><a target="_blank" href="https://www.youtube.com/watch?v=gtjzjiTI96c&list=PLfXiENmg6yyUpIVY9XVOkbdmBPx6PUm9_">Netflix</a></li>
						<li><a target="_blank" href="https://source.opennews.org/en-US/articles/nyt-redesigns-mobile/">New York Times</a></li>
						<li><a target="_blank" href="https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/">PayPal</a> </li>
						<li><a target="_blank" href="http://highscalability.com/blog/2012/10/4/linkedin-moved-from-rails-to-node-27-servers-cut-and-up-to-2.html">LinkedIn</a></li>
						<li><a target="_blank" href="https://medium.com/@nodejs/how-uber-uses-node-js-to-scale-their-business-cd4d8f8e4187#.rf4v5rw0w">Uber</a> </li>
						<li><a target="_blank" href="https://www.joyent.com/blog/node-js-at-walmart-introduction">Wallmart</a> </li>
						<li><a target="_blank" href="http://blog.fogcreek.com/the-trello-tech-stack/">Trello</a></li>
						<li><a target="_blank" href="http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/">Airbnb</a></li>
					</ol>

					<aside class="notes">
					  These companies receive an insane amount of requests,
						the scale on which they work is gigantic, and they've chosen
						node because of their scalability and ease of use.

						In fact lets read it from the guys themselves.
					</aside>
				</section>

				<section>
					<h2>Paypal</h2>
					<p>
						<img width="90%" src="img/paypal.png"  />

						<aside class="notes">
						  PayPal has rewritten part of their existing applications using Node, so they
							where able to measure the difference, the gain, in empirical numbers of
							using Node.
						</aside>
					</p>
				</section>

				<section>
					<h2>LinkedIn</h2>
					<p>
						<img width="90%" src="img/linked-in.png" />

						<aside class="notes">
						  LinkedIn did the same and have seen an increase in speed while
							decreasing the amount of computing power required.

							That's money in the hand.
						</aside>
					</p>
				</section>

				<section>
					<h2>Uber</h2>
					<p>
						<img width="90%" src="img/uber.png" />

						<aside class="notes">
						  You're starting to see a pattern here right? Node is really good
							at scaling at pace.
						</aside>
					</p>
				</section>

				<section>
					<h2>Wallmart</h2>
					<p>
						<img src="img/wallmart.png" alt="" />
					</p>

					<aside class="notes">
					  This is a frame from a talk from Walmart (the link is on the slides),
						where they talked about how they use Node, this image feels quite familiar
						with what we have at GOL as a backend.

						They actually created and open sourced a pretty good plugin based server
						library called hapi, according to their website used by companies like
						Disney, Macy's, mozilla, PayPal and others.
					</aside>
				</section>

				<section>
					<h2>Scale</h2>
					<p>
						Is it all the InfraDevs job? Or can we do something about it?<br />
						<img src="img/devops.jpg" alt="" />
					</p>

					<aside class="notes">
					  I think we sould all realize that building at scale is a systemic issue,
						you don't solve it in just one end of the chain, it needs to
						be build end to end.

						Build to scale from the start and you'll never have to worry about load.
					</aside>
				</section>

				<section>
					<h2>Scale</h2>
					<p>
						In two commands you can have a cluster, one instance per CPU
<pre><code class="hljs sh" data-trim contenteditable>
$ npm install pm2 --global
$ pm2 start app.js -i 0
</code></pre>
						<img src="img/pm2.png" />
					</p>

					<aside class="notes">
					  PM2 is a wonderful tool, it's the best process manager for node out there,
						Makes sure your application is always running, even after a crash,
						allows you to demonize your app,
						gathers logs for you,
						and lets you run in cluster mode.

						By running this command I now have quadrupled the amount of requests
						my application can handle, and that's only on my laptop, can you imagine
						what you can do on a 32 CPU AWS machine? Maybe you don't need that many servers
						after all.
					</aside>
				</section>

				<section>
					<h2>Abundance</h2>
					<p>
						Javascript was the most popular language in 2015 by third year in a row.<br />
						<img src="img/overflow.png" /><br />
						<small>StackOverflow</small>
					</p>

					<aside class="notes">
					  I'm not saying it's not difficult to find a good Node developer,
						but the pool of possible applicants is way way bigger than say Go developers.

						The language is not new, it has been around for a long time, but has been able
						to modernize and grow, new patterns are emerging.
					</aside>
				</section>

				<section>
					<h2>Versatility</h2>
					<p>
						What would you say if you could have an engineer that could do all these things:
						<ul>
							<li><a target="_blank" href="http://www.nodecopter.com/">Drones</a></li>
							<li><a target="_blank" href="http://node-ardx.org/">Arduino</a></li>
							<li><a target="_blank" href="http://electron.atom.io/">Cross-platform Desktop apps</a></li>
							<li><a target="_blank" href="https://facebook.github.io/react-native/">Native mobile apps</a></li>
							<li><a target="_blank" href="https://developer.atlassian.com/blog/2015/11/scripting-with-node/">Command line tools</a></li>
							<li><a target="_blank" href="https://github.com/pebble/pebblejs">Smart watches</a></li>
						</ul>
					</p>

					<aside class="notes">
					  What would you think if I tell you, you can have an engineer that can code:...
					</aside>
				</section>

				<section>
					<h2>Versatility</h2>
					<p>
						Oh.. and you know, universal (isomorphic) web applications.<br />
						<img src="img/mind_blown.gif" alt="" />
					</p>
					<aside class="notes">
					  The case of universal or isomorphic applications could take a whole talk
						by itself, but it is a trend that is gaining traction on the web industry,
						and one that can obviously only be solved by Node.

						The practicality of reusing the same code you use on the frontend as a single page
						app to render on the server side is undeniable, and solves most of the problems
						associated with the rising of frontend frameworks and libraries.

						This is the approach we're following at Texan and is giving very good results.
					</aside>
				</section>

				<section>
					<h2>Fast to learn, fast to code, fast to execute</h2>
					<p>
						It's perfect for an agile environment, you can quickly build an MVP and
						keep iterating until you have all the features you need.
					</p>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>Tooling is too cumbersome</h3>
					<p>
						Node !== Frontend<br />
						You don't need the same tooling on the backend than you need on the frontend.<br />
						<a target="_blank" href="https://nodejs.org/en/blog/release/v6.0.0/">Node v6 (soon to become LTS)</a> supports most of ES6 (96% at the time of this presentation), no need for transpiling.<br />
						No need for gulp/grunt, npm scripts can solve all your needs (start, test, build, etc).
					</p>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>NPM installs a bunch of nested dependencies</h3>
					<p>
						As of NPM v3 dependencies are installed in a flatten file structure, if the same package
						is needed in a bunch of dependencies it's only installed once.
					</p>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>You need a lot of micro-dependencies</h3>
					<p>
						No need for frameworks and all their baggage.<br />
						To write a proper microservice you really only need 3 packages, the implementation is up to you.
						<ul>
							<li>A server (such as <code>restify</code>)</li>
							<li>A logger (such as <code>bunyan</code>)</li>
							<li>A db handler/model (such as <code>mongoose</code>)</li>
							<li>Or a fetch library if your data lives somewhere else (such as <code>node-fetch</code>)</li>
						</ul>
					</p>

					<aside class="notes">
						Other people might complain about third party packages not being updated or
					  All languages have dependencies in other people's packages, I think it
						would be an error to think this is a Node problem
					</aside>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>Callback hell / Pyramid of doom</h3>
<pre><code class="hljs js" data-trim contenteditable>
asyncStuff1( ( err, result1 ) => {
	if ( err ) //handle error
  asyncStuff2( result1, ( err, result2 ) => {
		if ( err ) //handle error
    asyncStuff3( result2, ( err, result3 ) => {
			if ( err ) //handle error
      asyncStuff4( result3, ( err, result4 ) => {
				if ( err ) //handle error
        asyncStuff5( result4, ( err, result5 ) => {
					if ( err ) //handle error
          // do something useful
        })
      })
    })
  })
})
</code></pre>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>This is solved by Promises</h3>
<pre><code class="hljs js" data-trim contenteditable>
asyncStuff1()
.then( asyncStuff2 )
.then( asyncStuff3 )
.then( asyncStuff4 )
.then( asyncStuff5 )
.catch( error => {
	//Write only one error handler
	//All errors will come here
})
</code></pre>
				</section>

				<section>
					<h2>Misconceptions</h2>
					<h3>Is not reliable</h3>
					<p>
						Node has grown a lot and fast lately, there was troubled times at the beginning, but
						it now has a strong open source foundation behind it, and a robust community making it
						more secure, fast and reliable every day.
					</p>
				</section>

				<section>
					<h2>My favorites</h2>
					<ul>
						<li>Isomorphic SSR</li>
						<li>Websockets</li>
						<li>JSON</li>
						<li>
							ES6
							<ul>
								<li>Arrow functions <code>x => x * 2</code></li>
								<li>Promises</li>
								<li>Short notations in general <code>{ prop }</code></li>
								<li>Deconstruction <code>{ prop1, prop2 } = obj</code></li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<h2>End of part 1</h2>
					<h3>Q&A</h3>
					<blockquote cite="https://blog.codinghorror.com/the-principle-of-least-power/">
						"Any application that can be written in JavaScript, will eventually be written in JavaScript"<br /><br />
						<small>-- "Atwood's Law" (Jeff Atwood, 2007)</small>
					</blockquote>

					<aside class="notes">
					  I want to end part 1 with this quote from Jeff Atwood, Jeff is a co-founder at StackOverflow
						and creator of Discourse forum solution.

						It comes from 'The Principle of Least Power' formulated Tim Berners-Lee:
						Principle: Powerful languages inhibit information reuse.
						Good Practice: Use the least powerful language suitable for expressing information, constraints or programs on the World Wide Web.
					</aside>
				</section>

				<section>
					<h2>Part 2: Programming techniques</h2>
					<p>
						Goals<br />
						Make our code:

						<ul>
							<li>Easy to read</li>
							<li>Easy to understand</li>
							<li>Easy to reason about</li>
						</ul>
					</p>

					<aside class="notes">
					  Reason about refers to executing the code in our heads,
						we read thousands of lines of code every day, the quicker we can
						comprehend what it does and follow the execution the better we
						can find bugs and refactor different bits.

						As a rule of thumb, you could measure it as how fast can you give
						an output given a certain input.

						To understand these techniques better, we're going to see it in a practical
						manner, we'll start with some initial code, and we'll improve it using the
						technique
					</aside>
				</section>

				<section>
					<h2>Return early technique</h2>
					<img width="70%" src="img/return-early.jpg" alt="" />

					<aside class="notes">
					  This a language agnostic technique, you can apply it almost
						any back end and front end language.

						Most of you are probably using this already, but we have developers
						with all kinds of experiences here and I think it's a good pattern
						for everyone to know.
					</aside>
				</section>

				<section>
					<h2>Initial code</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
	let { errorKey, errorMessage } = error;

	let errorString = '';

	if ( errorKey ) {
		if ( errorConstants[ errorKey ] ) {
			errorString = errorConstants[ errorKey ];
		} else if ( errorMessage ) {
			errorString = errorMessage;
		} else {
			errorString = errorKey;
		}
	} else if ( typeof error === 'string' ) {
		if ( errorConstants[ error ] ) {
			errorString = errorConstants[ error ];
		} else {
			errorString = error;
		}
	} else {
		errorString = config.MAIN_ERROR;
	}

	return errorString;
};
					</code></pre>
					<aside class="notes">
					  When you read and understand this code, every if, every else
						and every return represents a branch you need to keep track of.

						You could represent this as a tree, a conditional tree.
					</aside>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img src="img/conditional-tree.png" alt="" />
					</p>

					<aside class="notes">
					  In here we can see the tree that we need to create in our
						head in order to branch through the different scenarios.

						When I mentioned the reason about part, this is what happens in
						your head when you try to get an output.

						The highlighted leaf nodes represent the values that we return,
						these are the most important part, but there are other ways of getting
						the same output.

						Lets see how could we improve this code.
					</aside>
				</section>

				<section>
					<h2>Cut down the <code>else</code>s</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey ) {
    if ( errorConstants[ errorKey ] ) return errorConstants[ errorKey ];
    if ( errorMessage  ) return errorMessage;
    return errorKey;
  }

  if ( typeof error === 'string' ) {
    if ( errorConstants[ error ] ) return errorConstants[ error ];
    return error;
  }

  return config.MAIN_ERROR;
};
					</code></pre>

					<aside class="notes">
					  The first step is to cut down the elses, if instead of
						keeping the value we want to return on a variable and returning
						it at the end of the function we return the value as soon as we know it's
						value that we want, we're stopping the execution of the function.

						That means that nothing else can happen, and that if the execution
						continues, the previous case didn't happen. This logic removes
						the need for else statements, and it simplyfies our tree.
					</aside>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img src="img/conditional-tree-mod1.png" alt="" />
					</p>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img src="img/conditional-tree-mod1-s.png" alt="" />
					</p>

					<aside class="notes">
					  This is much much better now, we reduced the number of branches
						on our tree, and its now more straight forward.

						But there's still another improvement we can do, and this might
						be counter intuitive at first for some of you, but bear with me.
					</aside>
				</section>

				<section>
					<h2>One <code>if</code> deep</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey && errorConstants[ errorKey ] ) return errorConstants[ errorKey ];
  if ( errorKey && errorMessage  ) return errorMessage;
  if ( errorKey ) return errorKey;

  if ( typeof error === 'string' && errorConstants[ error ] ) return errorConstants[ error ];
  if ( typeof error === 'string' ) return error;

  return config.MAIN_ERROR;
};
					</code></pre>

					<aside class="notes">
					  Yes, we are repeating the errorKey in different places, repeating something
						is not always a capital offence, if it gives us something in return.

						And I hear you think, oh but now the line is too long, well aesthetics can
						be fixed in other ways.
					</aside>
				</section>

				<section>
					<h2>One <code>if</code> deep</h2>
					<pre><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey
    && errorConstants[ errorKey ] ) return errorConstants[ errorKey ];

  if ( errorKey
    && errorMessage  ) return errorMessage;

  if ( errorKey ) return errorKey;

  if ( typeof error === 'string'
    && errorConstants[ error ] ) return errorConstants[ error ];

  if ( typeof error === 'string' ) return error;

  return config.MAIN_ERROR;
};
					</code></pre>

					<aside class="notes">
					  But now our function is just a series of if statements, we know
						that each of them is only going to happen if none of the previous ones
						happened, and of top of it, it's so declarative it's almost as reading plain
						english.

						if error key is defined and error constant is defined return error constant.

						Let's take a look at our conditional tree now.
					</aside>
				</section>

				<section>
					<h2>Conditional Tree</h2>
					<p>
						<img width="75%" src="img/conditional-tree-mod2.png" alt="" />
					</p>

					<aside class="notes">
					  Wow, isn't it gorgeous? We managed to cut down all the branches
						to almost the same depth.

						Now when we read this code given an input we can almost tell instantly
						what the output is because the conditions are written sequentially
						and in plain english.
					</aside>
				</section>

				<section>
					<h2>Before and after</h2>
					<pre class="half"><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
	let { errorKey, errorMessage } = error;

	let errorString = '';

	if ( errorKey ) {
		if ( errorConstants[ errorKey ] ) {
			errorString = errorConstants[ errorKey ];
		} else if ( errorMessage ) {
			errorString = errorMessage;
		} else {
			errorString = errorKey;
		}
	} else if ( typeof error === 'string' ) {
		if ( errorConstants[ error ] ) {
			errorString = errorConstants[ error ];
		} else {
			errorString = error;
		}
	} else {
		errorString = config.MAIN_ERROR;
	}

	return errorString;
};
					</code></pre>
					<pre class="half"><code class="hljs js height-auto" data-trim contenteditable>
const handleError = ( error ) => {
  let { errorKey, errorMessage } = error;

  if ( errorKey && errorConstants[ errorKey ] ) return errorConstants[ errorKey ];
  if ( errorKey && errorMessage  ) return errorMessage;
  if ( errorKey ) return errorKey;

  if ( typeof error === 'string' && errorConstants[ error ] ) return errorConstants[ error ];
  if ( typeof error === 'string' ) return error;

  return config.MAIN_ERROR;
};
					</code></pre>

					<aside class="notes">
					  Take a look at the length difference of the before and after.

						We've removed code and complexity and we've gained readability.
					</aside>
				</section>

				<section>
					<h2>Recap</h2>
					<p>
						When you see lots of nested <code>if</code> or/and lots of <code>else</code> statements:

						<ol>
							<li>Cut down the <code>else</code>s</li>
							<li>One <code>if</code> deep</li>
						</ol>
					</p>

					<aside class="notes">
					  We've done all of this with only two simple steps.

						Sometimes you only need the first one, and that's fine.
					</aside>
				</section>

				<section>
					<h2>Functional programming</h2>
					<p>
						<img src="img/function-js.jpg" alt="" />
					</p>

					<aside class="notes">
					  Functional programming is one of the first programming paradigms formulated which
						it gave birth to one of the programming languages (lisp), and it sounds very
						academical and unapproachable, but it's really just a set of principles to
						think about when your writing your code.

						Not everything that we write has to follow these principles, but the more
						we do it the better.
					</aside>
				</section>

				<section>
					<h2>Principles</h2>
					<p>
						A set of patterns when we write our code:
						<ul>
							<li>Small single purpose functions</li>
							<li>Pure functions
								<ul>
									<li>No side effects</li>
									<li>Data should be immutable</li>
									<li>Avoid non predictable values (i.e. Date)</li>
								</ul>
							</li>
							<li>Stateless</li>
							<li>Composable</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>ROI</h2>
					<p>
						<ul>
							<li>Testable</li>
							<li>Portable (reusable)</li>
							<li>Memoizable</li>
							<li>Parallelizable</li>
							<li>Less prone to bugs</li>
							<li>More readable</li>
						</ul>
					</p>

				</section>

				<section>
					<h2>Language prerequisites</h2>
					<p>
						<ul>
							<li>Functions are "first-class" objects
								<ul>
									<li>Functions can be assigned to a variable</li>
								</ul>
							</li>
							<li>Higher-order functions
								<ul>
									<li>Functions can be passed as a parameter to another function</li>
									<li>Functions can return other functions</li>
								</ul>
							</li>
						</ul>
					</p>

					<aside class="notes">
					  Before we start looking at examples, a short intermission
						 about arrow functions.
					</aside>
				</section>

				<section>
					<h2>Intermission: Arrow functions</h2>
<pre><code class="hljs js" data-trim contenteditable>
//Before
var a = function( arg1, arg2 ) {
	//doStuff
	return something;
};

//With ES6
const a = ( arg1, arg2 ) => {
	//doStuff
	return something;
};

//If your function has only one expression and its a return
const a = ( arg1, arg2 ) => expression;

//If your function has only one argument
const a = arg1 => expression;
</code></pre>

					<aside class="notes">
					  Arrow functions are a new language feature of ES6 that I really love,
						because it makes you write less code, and forces you to use more of the
						functional programming principle because it just looks so much better!

						In javascript (as of ES6) and I'm sure in lots of other languages or libraries in other
						languages, we have some built-in high-order functions for arrays, that we
						should really master to get most of functional programming.

						Let's take a look at a few.
					</aside>
				</section>

				<section>
					<h2>Higher-order functions for Arrays</h2>
					<h3>Map</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Multiply all the elements by 2 */
a.map( x => x * 2 );
//[ 2, 4, 6, 8 ]
</code></pre>
					<aside class="notes">
						Map returns a new array, with the same lengths of the original
						one with a transformation applied to each element.

						That function is the callback we pass.

					  Notice that a is constant, therefore map is returning
						a new array with the same length as the original one without
						modifying a.
					</aside>
				</section>

				<section>
					<h2>Higher-order functions for Arrays</h2>
					<h3>forEach</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Log every array element */
a.forEach( x => console.log(x) );
//1
//2
//3
//4
</code></pre>
					<aside class="notes">
					  forEach lets us traverse an array applying
						a callback to each element but it doesn't return anything
					</aside>
				</section>

				<section>
					<h2>Higher-order functions for Arrays</h2>
					<h3>filter</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Return an array with pair numbers */
a.filter( x => x % 2 === 0 );
//[ 2, 4 ]
</code></pre>
				<aside class="notes">
				  Filter accepts a callback which uses to check if an array
					element should be included in the output or not.
					In this case the number where mod 2 is 0 , therefor pair.
					Again it returns a brand new array without touching the original.
				</aside>
				</section>

				<section>
					<h2>Higher-order functions for Arrays</h2>
					<h3>reduce</h3>
<pre><code class="hljs js" data-trim contenteditable>
const a = [ 1, 2, 3, 4 ];
/* Sum all elements of the array */
a.reduce( ( previous, current ) => previous + current, 0 );
//10
const b = [ 'John Smith', 'George Clooney' ];
/* Produce an object with arrays for all firstNames and lastNames */
b.reduce( ( previous, current ) => {
	let parts = current.split(' ');
	previous.firstNames.push( parts[0] );
	previous.lastNames.push( parts[1] );
	return previous;
}, {
	firstNames: [],
	lastNames: []
});
//{ firstNames: [ 'John', 'George' ],
//  lastNames: [ 'Smith', 'Clooney' ] }
</code></pre>

					<aside class="notes">
					  Reduce is maybe the most powerful and yet the most
						underused of them all.

						Reduce accepts TWO arguments the first one is a function which
						receives two arguments, the first is the previously returned value, the second
						is the current element on the array, and it returns the value for the next iteration.

						The second argument is the initial value of previous.

						We can use it to, for example sum all the elements of the array, or more complex
						example such as constructing an object from an array.

						It may be a bit difficult to get your head around at first, but once you start using it
						you find use cases everywhere.

						So lets jump to our initial code that we want to optimize.
					</aside>
				</section>

				<section>
					<h2>Initial code</h2>
<pre><code class="hljs js height-auto" data-trim contenteditable>
const c  = [
	{ name: 'John', vote: 'leave', age: 60 },
	{ name: 'Mary', vote: 'remain', age: 25 },
	{ name: 'Dorothy', vote: 'leave', age: 75 },
	{ name: 'Mark', vote: 'remain', age: 35 },
];
/* Calculate average age of remain and leave voters */
let leaveAgeSum = 0, leaveVoters = 0, remainAgeSum = 0, remainVoters = 0;

for ( let i in c ) {
	let voter = c[i];
	if ( voter.vote === 'leave' ) {
		leaveAgeSum += voter.age;
		leaveVoters++;
	}
	if ( voter.vote === 'remain' ) {
		remainAgeSum += voter.age;
		remainVoters++;
	}
}

let leaveAvg = leaveAgeSum / leaveVoters;
//67.5
let remainAvg = remainAgeSum / remainVoters;
//30
</code></pre>

				<aside class="notes">
				  So this is our starting code, we're given an array of objects
					about voters, including their name, vote and age.

					And we're asked to calculate the average age of each vote group.

					We could do it like that, inside some kind of for loop, accumulate the
					age and the totals and calculate the average.

					But judging from what we've just seen from higher-order functions in arrays,
					there's probably a better way of doing this.
				</aside>
				</section>

				<section>
					<h2>Applying what we learned about higher-order functions for Arrays</h2>
<pre><code class="hljs js height-auto" data-trim contenteditable>
const c  = [
	{ name: 'John', vote: 'leave', age: 60 },
	{ name: 'Mary', vote: 'remain', age: 25 },
	{ name: 'Dorothy', vote: 'leave', age: 75 },
	{ name: 'Mark', vote: 'remain', age: 35 },
];
/* Calculate average age of remain and leave voters */

let leaveVoters = c.filter( x => x.vote === 'leave' );
let leaveAgeSum = leaveVoters.reduce( ( p, c ) => p + c.age, 0 );
let leaveAvg    = leaveAgeSum / leaveVoters.length
//67.5

let remainVoters = c.filter( x => x.vote === 'remain' );
let remainAgeSum = remainVoters.reduce( ( p, c ) => p + c.age, 0 );
let remainAvg 	 = remainAgeSum / remainVoters.length;
//30
</code></pre>

				<aside class="notes">
				  We can use filter to get the vote group, we can use reduce to
					calculate the age sum, and then we can just calculate the average.

					See how by using this functions we broke it into discrete steps, instead
					of smashing everything into a for loop.

					You probably are seeing that now the two blocks of code for leavers and remainers
					looks almost the same, just the variable names and the vote filter value changes.

					So I'm sure we could abstract the same functionality for both groups.
				</aside>
				</section>

				<section>
					<h2>Create pure functions</h2>
<pre><code class="hljs js" data-trim contenteditable>
const filterVoters = ( c, type ) => c.filter( x => x.vote === type );

const sumAge       = c => c.reduce( ( p, c ) => p + c.age, 0 );

const calcAvg      = ( sum, total ) => sum / total;
</code></pre>

					<aside class="notes">
					  As you see these are pure functions, they only do one thing only,
						they don't modify any data they receive, and they don't have any side effects.

						You can run them as many times as you want and if the inputs are the same
						the outputs will be the same too.

						So how to we combine them to accomplish the operations we want?
						There's one thing missing to be able to chain them, calcAvg expects
						two arguments, but sumAge only returns one.
					</aside>
				</section>

				<section>
					<h2>Make them chainable</h2>
<pre><code class="hljs js" data-trim contenteditable>
const filterVoters = ( c, type ) => c.filter( x => x.vote === type );

const sumAge       = c => ({
	sum  : c.reduce( ( p, c ) => p + c.age, 0 ),
	total: c.length
});

const calcAvg      = ( params ) => params.sum / params.total;

calcAvg( sumAge( filterVoters( c, 'leave' ) ) );
//67.5

calcAvg( sumAge( filterVoters( c, 'remain' ) ) );
//30
</code></pre>

				<aside class="notes">
				  We can solve it by returning both values in an object, and now
					we can combine the functions to get the results we want.

					We're now using the same functions to accomplish both operations,
					so we were able to reuse the code and only write it once.

					Also we can now test each function separately.

					Now the next step is optional and very much specific to javascript,
					we accomplished what we wanted, but if we want to keep combining steps,
					this line can get pretty long, and changing the order or adding a new
					step can be cumbersome. There is a better way. Using Promises.
				</aside>
				</section>

				<section>
					<h2>Intermission: Promises</h2>
					<h4>They're useful for async stuff</h4>
					<p>
<pre><code class="hljs js" data-trim contenteditable>
const doSomethingAsync = ( a ) => {
	return new Promise(( resolve, reject) => {
		asyncThing(( err, result) => {
			if ( err ) return reject( err );
			return resolve( result );
		})
	})
};

doSomethingAsync( a )
.then( x => console.log(x) )
.catch( err => console.error(err) )
</code></pre>
					</p>

					<aside class="notes">
					  This is a classic example of a promise
						on an async operation.

						We return a new promise which accept a callback with two
						arguments which are also callbacks, resolve and reject.

						When we have result we want we call resolve with it.
						If something goes wrong we call reject with the error. Simple right?

						But we're not doing anything async in this example why should this be useful?
					</aside>
				</section>

				<section>
					<h2>Intermission: Promises</h2>
					<h4>But they're also useful for non async stuff</h4>
<pre><code class="hljs js" data-trim contenteditable>
const multiplyByTwo = ( a ) => {
	if ( isNaN(a) ) return Promise.reject( 'Not a number' );
	return Promise.resolve( a * 2 );
};

multiplyByTwo( a )
.then( x => console.log(x) )
.catch( err => console.error(err) )
</code></pre>
					<aside class="notes">
					  Because they can also be used in a different way in sync stuff.

						We can return Promise.resolve and Promise.reject, to get the same
						thenable functions and trigger catch blocks.

						Ok so now that we know this, lets apply it to our functions.
					</aside>
				</section>

				<section>
					<h2>Use Promise.resolve</h2>
<pre><code class="hljs js height-auto" data-trim contenteditable>
const filterVoters = ( c, type ) => Promise.resolve(
	c.filter( x => x.vote === type )
);

const sumAge       = c => Promise.resolve({
	sum  : c.reduce( ( p, c ) => p + c.age, 0 ),
	total: c.length
});

const calcAvg      = ( params ) => Promise.resolve(
	params.sum / params.total
);

filterVoters( c, 'leave' )
.then(sumAge)
.then(calcAvg)
.then( x => console.log(x) );
//67.5

filterVoters( c, 'remain' )
.then(sumAge)
.then(calcAvg)
.then( x => console.log(x) );
//30
</code></pre>

				<aside class="notes">
				  Now that we've used promises it's clearer what the steps are
					and quite easy to add a new step in between, or change the order.

					Also it's more readable and easier to reason about.

					Again like on the return early example, our code becomes almost
					plain english, filter the voters then sum the ages then calculate the average
					and then log the result

					But there's one more thing that promises gives us.
				</aside>
				</section>

				<section>
					<h2>Error handling: Promise.reject</h2>
<pre><code class="hljs js height-auto" data-trim contenteditable>
const filterVoters = ( c, type ) => {
	if ( !c.length ) return Promise.reject('Empty array');
	return Promise.resolve( c.filter( x => x.vote === type ) )
};

const sumAge       = c => Promise.resolve({
	sum  : c.reduce( ( p, c ) => p + c.age, 0 ),
	total: c.length
});

const calcAvg      = ( params ) => Promise.resolve(
	params.sum / params.total
);

filterVoters( [], 'leave' )
.then(sumAge)
.then(calcAvg)
.then( x => console.log(x) )
.catch( error => console.log('Error!', error) );
//Error! Empty array
</code></pre>

				<aside class="notes">
				  We can add error handling. In this case, we don't want to
					go through all the steps if our array is empty because its going to fail

					So we want to stop the chain when we realize the array is empty, Promise.reject
					lets us do that.

					Because of the nature of promises it also allows us to have a single error handler
					for all the thing that could go wrong on the chain this also reducing the amount
					of code we need to write to handle errors.
				</aside>
				</section>

				<section>
					<h2>Recap</h2>
					<p>
						<ul>
							<li>Use array higher-order functions</li>
							<li>Create small pure functions</li>
							<li>Make them reusable</li>
							<li>Make them chainable</li>
							<li>Test them</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>End of part 2</h2>
					<h3>Q&A</h3>
					<p>
						<blockquote cite="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4#.a41dwcshm">
							"Developers proficient in functional programming are going to be
							in large demand in the very near future."<br /><br />
							<small>-- Eric Elliott, 2014 </small>
						</blockquote>
					</p>
				</section>

				<section>
					<h2>Thank you!</h2>
					<p>
						<ul>
							<li>This slides: <a target="_blank" href="http://bit.ly/node-talk">http://bit.ly/node-talk</a></li>
							<li>Nodejs Workshop: <a target="_blank" href="http://bit.ly/node-workshop">http://bit.ly/node-workshop</a></li>
							<li>Discuss: <a target="_blank" href="https://sainsburyslab.slack.com/messages/discuss-nodejs/">#discuss-nodejs</a></li>
							<li>Slack me: <a target="_blank" href="https://sainsburyslab.slack.com/messages/@marti/">@marti</a></li>
							<li><a target="_blank" href="https://github.com/JSainsburyPLC/texan-node-service">texan-node-service library</a></li>
						</ul>
					</p>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				transition: 'convex',
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({tabReplace: '  '}); hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
